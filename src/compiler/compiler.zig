const std = @import("std");
const ast = @import("../frontend/ast.zig");
const object = @import("object.zig");
const opcode = @import("instruction.zig").Instruction;

pub const Program = struct {
    bytecode: std.ArrayList(u8),
    constantPool: std.ArrayList(object.Object),
    globalVariables: std.StringHashMap(object.Object),
    // functionRegistry: std.StringHashMap([]const u8),
};

pub const Compiler = struct {
    ast: ast.Ast,
    alloc: std.mem.Allocator,
    program: Program,

    pub fn new(alloc: std.mem.Allocator, astNodes: ast.Ast) Compiler {
        return Compiler{
            .ast = astNodes,
            .alloc = alloc,
            .program = Program{
                .bytecode = std.ArrayList(u8).initCapacity(alloc, 1024) catch {
                    @panic("Failed to allocate memory for bytecode instructions");
                },
                .constantPool = std.ArrayList(object.Object).initCapacity(alloc, 16) catch {
                    @panic("Failed to allocate memory for constant pool");
                },
                .globalVariables = std.StringHashMap(object.Object).init(alloc),
                // .functionRegistry = std.StringHashMap([]const u8).init(alloc),
            },
        };
    }

    pub fn deinit(self: *Compiler) void {
        self.program.constantPool.deinit(self.alloc);
        self.program.bytecode.deinit(self.alloc);
    }

    pub fn dumpBytecode(self: *Compiler) !void {
        const file = try std.fs.cwd().createFile("out.hex", .{});
        defer file.close();

        var buffer: [4096]u8 = undefined;

        _ = try file.write("# File generated by the Zython interpreter\n");
        _ = try file.write("# Bytecode Hex Dump\n\n");

        var line: u32 = 0;
        const x = std.fmt.bufPrintZ(buffer[0..], "{d:04}  ", .{line}) catch unreachable;
        _ = try file.write(x);

        for (self.program.bytecode.items) |byte| {
            const result = std.fmt.bufPrintZ(buffer[0..], "0x{x:02} ", .{byte}) catch unreachable;
            _ = try file.write(result);

            line += 1;

            if (line % 10 == 0) {
                _ = try file.write("\n");
                const a = std.fmt.bufPrintZ(buffer[0..], "{d:04}  ", .{line / 10}) catch unreachable;
                _ = try file.write(a);
            }
        }
    }

    pub fn print(self: *Compiler) void {
        std.debug.print("Bytecode:\n", .{});
        for (self.program.bytecode.items, 0..) |byte, i| {
            std.debug.print("{d:04}: {d}\n", .{ i, byte });
        }

        std.debug.print("\nConstants:\n", .{});
        for (self.program.constantPool.items, 0..) |val, i| {
            std.debug.print("index: {d} = {any}\n", .{ i, val });
        }
    }

    pub fn compileBytecode(self: *Compiler) void {
        for (self.ast.statements.items) |node| {
            self.compileNode(node);
        }
    }

    fn compileNode(self: *Compiler, node: *ast.AstNode) void {
        switch (node.as) {
            .AstBinaryExpression => self.compileBinaryExpression(&node.as.AstBinaryExpression),
            .AstUnaryExpression => self.compileUnaryExpression(&node.as.AstUnaryExpression),
            .AstCallExpression => self.compileCallExpression(&node.as.AstCallExpression),
            .AstVariableDeclaration => self.compileVariableDeclaration(&node.as.AstVariableDeclaration),
            .AstIdentifier => self.compileIdentifierUsage(&node.as.AstIdentifier),
            .AstFunctionDefinition => self.compileFunctionDefinition(&node.as.AstFunctionDefinition),
            .AstCompoundAssignment => self.compileCompoundAssignment(&node.as.AstCompoundAssignment),
            .AstAssert => self.compileAssert(&node.as.AstAssert),
            .AstRaise => self.compileRaise(&node.as.AstRaise),
            .AstIfStatement => self.compileIf(&node.as.AstIfStatement),
            .AstPass => self.compilePass(&node.as.AstPass),
            .AstWhileStatement => self.compileWhile(&node.as.AstWhileStatement),
            .AstBreak => self.compileBreak(&node.as.AstBreak),
            .AstContinue => self.compileContinue(&node.as.AstContinue),
            else => self.compilePrimaryExpression(node),
        }
    }

    fn compileBreak(self: *Compiler, node: *ast.AstBreakNode) void {
        _ = self;
        _ = node;
    }

    fn compileContinue(self: *Compiler, node: *ast.AstContinueNode) void {
        _ = self;
        _ = node;
    }

    fn compileWhile(self: *Compiler, node: *ast.AstWhileStatementNode) void {
        const loopStart = self.program.bytecode.items.len;

        self.compileNode(node.condition);

        self.emitInstruction(opcode.JumpIfFalse);
        const exitJump = self.program.bytecode.items.len;
        self.emitByte(0x00);
        self.emitByte(0x00);

        self.compileNodes(node.body);

        self.emitInstruction(opcode.Jump);

        const jumpPosition = self.program.bytecode.items.len;
        const offset: i16 = @as(i16, @intCast(loopStart)) - @as(i16, @intCast(jumpPosition)) - 2;

        const unsignedOffset: u16 = @bitCast(offset);
        self.emitByte(@intCast(unsignedOffset & 0xFF));
        self.emitByte(@intCast((unsignedOffset >> 8) & 0xFF));

        self.patchJump(exitJump);
    }

    fn compileNodes(self: *Compiler, nodes: std.ArrayList(*ast.AstNode)) void {
        for (nodes.items) |stmt| {
            self.compileNode(stmt);
        }
    }

    fn compilePass(self: *Compiler, _: *ast.AstPassNode) void {
        self.emitInstruction(opcode.Nop);
    }

    // thanks, Robert Nystrom
    fn patchJump(self: *Compiler, offset: usize) void {
        const jumpTarget = self.program.bytecode.items.len;
        const jumpOffset = jumpTarget - offset - 2;

        self.program.bytecode.items[offset] = @intCast(jumpOffset & 0xFF);
        self.program.bytecode.items[offset + 1] = @intCast((jumpOffset >> 8) & 0xFF);
    }

    fn compileIf(self: *Compiler, node: *ast.AstIfStatementNode) void {
        self.compileNode(node.condition);
        self.emitInstruction(opcode.JumpIfFalse);

        const jumpOffsetPosition = self.program.bytecode.items.len;
        self.emitByte(0x00);
        self.emitByte(0x00);

        self.compileNodes(node.body);
        self.emitInstruction(opcode.Jump);

        const elseJumpOffsetPosition = self.program.bytecode.items.len;
        self.emitByte(0x00);
        self.emitByte(0x00);

        self.patchJump(jumpOffsetPosition);

        if (node.elseBody.items.len != 0) {
            self.compileNodes(node.elseBody);
            self.patchJump(elseJumpOffsetPosition);
        }
    }

    fn compileRaise(self: *Compiler, node: *ast.AstRaiseNode) void {
        _ = self;
        _ = node;
    }

    fn compileAssert(self: *Compiler, node: *ast.AstAssertNode) void {
        _ = self;
        _ = node;

        // self.compileNode(node.value);
        // jump past if true
        // otherwise, raise an exception
    }

    fn compileFunctionDefinition(self: *Compiler, node: *ast.AstFunctionDefinitionNode) void {
        _ = self;
        _ = node;
    }

    fn compileCompoundAssignment(self: *Compiler, node: *ast.AstCompoundAssignmentNode) void {
        if (node.operator == .Walrus) {
            self.compileNode(node.value);

            const nameObj = object.Object.newIdentifierObject(node.name);
            self.addConstant(nameObj);

            self.emitInstruction(opcode.StoreGlobal);

            self.compileNode(node.value);
            return;
        }

        const nameObj = object.Object.newIdentifierObject(node.name);
        self.addConstant(nameObj);
        self.emitInstruction(opcode.LoadGlobal);

        self.compileNode(node.value);

        self.addOperatorInstruction(node.operator);

        const storeNameObj = object.Object.newIdentifierObject(node.name);
        self.addConstant(storeNameObj);
        self.emitInstruction(opcode.StoreGlobal);
    }

    fn compileIdentifierUsage(self: *Compiler, node: *ast.AstIdentifierNode) void {
        const obj = object.Object.newIdentifierObject(node.name);
        self.addConstant(obj);

        self.emitInstruction(opcode.LoadGlobal);
    }

    fn compileUnaryExpression(self: *Compiler, unary: *ast.AstUnaryExpressionNode) void {
        self.compileNode(unary.left);

        switch (unary.operator) {
            ast.OperatorType.Minus => self.emitInstruction(opcode.Neg),
            ast.OperatorType.Plus => self.emitInstruction(opcode.UnaryPlus),
            ast.OperatorType.BitwiseNot => self.emitInstruction(opcode.BitNot),
            ast.OperatorType.Not => self.emitInstruction(opcode.Not),
            else => @panic("invalid operator in unary expression"),
        }
    }

    fn addOperatorInstruction(self: *Compiler, operator: ast.OperatorType) void {
        switch (operator) {
            ast.OperatorType.Plus => self.emitInstruction(opcode.Add),
            ast.OperatorType.Minus => self.emitInstruction(opcode.Sub),
            ast.OperatorType.Multiply => self.emitInstruction(opcode.Mul),
            ast.OperatorType.Divide => self.emitInstruction(opcode.Div),
            ast.OperatorType.Modulo => self.emitInstruction(opcode.Mod),
            ast.OperatorType.Exponentiation => self.emitInstruction(opcode.Exp),
            ast.OperatorType.FloorDivision => self.emitInstruction(opcode.FloorDiv),
            ast.OperatorType.BitwiseAnd => self.emitInstruction(opcode.BitAnd),
            ast.OperatorType.BitwiseOr => self.emitInstruction(opcode.BitOr),
            ast.OperatorType.BitwiseXor => self.emitInstruction(opcode.BitXor),
            ast.OperatorType.BitwiseNot => self.emitInstruction(opcode.BitNot),
            ast.OperatorType.BitwiseLeftShift => self.emitInstruction(opcode.BitLeftShift),
            ast.OperatorType.BitwiseRightShift => self.emitInstruction(opcode.BitRightShift),
            ast.OperatorType.LessThan => self.emitInstruction(opcode.Lt),
            ast.OperatorType.LessThanOrEquals => self.emitInstruction(opcode.Lte),
            ast.OperatorType.GreaterThan => self.emitInstruction(opcode.Gt),
            ast.OperatorType.GreaterThanOrEquals => self.emitInstruction(opcode.Gte),
            ast.OperatorType.Equals => self.emitInstruction(opcode.Eq),
            ast.OperatorType.NotEquals => self.emitInstruction(opcode.Neq),
            ast.OperatorType.And => self.emitInstruction(opcode.And),
            ast.OperatorType.Or => self.emitInstruction(opcode.Or),
            ast.OperatorType.Not => self.emitInstruction(opcode.Not),
            else => @panic("operator not supported"),
        }
    }

    fn compileBinaryExpression(self: *Compiler, binary: *ast.AstBinaryExpressionNode) void {
        self.compileNode(binary.left);
        self.compileNode(binary.right);

        self.addOperatorInstruction(binary.operator);
    }

    fn compileVariableDeclaration(self: *Compiler, node: *ast.AstVariableDeclarationNode) void {
        self.compileNode(node.value);

        const nameObj = object.Object.newIdentifierObject(node.name);
        self.addConstant(nameObj);

        self.emitInstruction(opcode.StoreGlobal);
    }

    fn compileCallExpression(self: *Compiler, node: *ast.AstCallExpressionNode) void {
        self.compileNodes(node.parameters);

        self.compilePrimaryExpression(node.callee);
        self.emitInstruction(opcode.Call);
    }

    fn compilePrimaryExpression(self: *Compiler, node: *ast.AstNode) void {
        switch (node.as) {
            .AstIntegerLiteral => {
                const obj = object.Object.newIntegerObject(node.as.AstIntegerLiteral.value);
                self.addConstant(obj);
            },
            .AstBooleanLiteral => {
                const obj = object.Object.newBoolObject(node.as.AstBooleanLiteral.value);
                self.addConstant(obj);
            },
            .AstIdentifier => {
                const obj = object.Object.newIdentifierObject(node.as.AstIdentifier.name);
                self.addConstant(obj);
            },
            .AstStringLiteral => {
                const obj = object.Object.newStringObject(node.as.AstStringLiteral.value);
                self.addConstant(obj);
            },
            else => @panic("Unknown node type in compiler"),
        }
    }

    fn addConstant(self: *Compiler, obj: object.Object) void {
        self.program.constantPool.append(self.alloc, obj) catch {
            @panic("Failed to add constant into constant pool");
        };

        const idx = self.program.constantPool.items.len - 1;

        if (idx > 255) {
            self.emitByte(@intFromEnum(opcode.PushConstantWide));
            const lowByte = idx & 0xff;
            const highByte = (idx >> 8) & 0xff;

            self.emitByte(@intCast(lowByte));
            self.emitByte(@intCast(highByte));
        } else {
            self.emitByte(@intFromEnum(opcode.PushConstant));
            self.emitByte(@intCast(idx));
        }
    }

    fn emitByte(self: *Compiler, instr: u8) void {
        self.program.bytecode.append(self.alloc, instr) catch {
            @panic("Failed to add instruction into bytecode array");
        };
    }

    fn emitInstruction(self: *Compiler, instr: opcode) void {
        self.program.bytecode.append(self.alloc, @intFromEnum(instr)) catch {
            @panic("Failed to add instruction into bytecode array");
        };
    }
};
